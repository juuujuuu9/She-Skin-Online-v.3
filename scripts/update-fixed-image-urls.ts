#!/usr/bin/env tsx
/**
 * Update Database Image URLs After Manual Upload
 * 
 * This script updates the database with new Bunny CDN URLs
 * after images have been manually uploaded to Bunny CDN.
 * 
 * Prerequisites:
 * 1. Images must be uploaded to Bunny CDN at: works/{category}/{filename}
 * 2. The tmp/fixable-images.json file must exist (generated by generate-image-fix-report.ts)
 * 
 * Usage: npx tsx scripts/update-fixed-image-urls.ts [--dry-run]
 */

import { db } from '../src/lib/db/index.js';
import { workMedia, media } from '../src/lib/db/schema.js';
import { eq } from 'drizzle-orm';
import { readFileSync } from 'fs';

const CONFIG = {
  fixableImagesPath: './tmp/fixable-images.json',
  bunnyCdnUrl: process.env.BUNNY_CDN_URL || 'https://she-skin.b-cdn.net',
};

interface FixableImage {
  category: string;
  title: string;
  slug: string;
  wpPostId: number;
  currentUrl: string;
  wordpressUrl: string;
  suggestedFilename: string;
}

function log(message: string, type: 'info' | 'success' | 'error' | 'warning' = 'info') {
  const icons = { info: 'â„¹ï¸', success: 'âœ…', error: 'âŒ', warning: 'âš ï¸' };
  console.log(`${icons[type]} ${message}`);
}

async function main() {
  console.log('ðŸ”„ Updating Database Image URLs\n');
  console.log('='.repeat(60));
  
  const isDryRun = process.argv.includes('--dry-run');
  
  if (isDryRun) {
    log('DRY RUN MODE - No changes will be made', 'warning');
  }
  
  // Load fixable images
  let fixableImages: FixableImage[];
  try {
    const content = readFileSync(CONFIG.fixableImagesPath, 'utf-8');
    fixableImages = JSON.parse(content);
    log(`Loaded ${fixableImages.length} fixable images`, 'success');
  } catch (error) {
    log(`Failed to load fixable images: ${error}`, 'error');
    log('Run: npx tsx scripts/generate-image-fix-report.ts first', 'info');
    process.exit(1);
  }
  
  // Get all works with media
  const allWorks = await db.query.works.findMany({
    with: {
      media: true,
    },
  });
  
  const worksBySlug = new Map(allWorks.map(w => [w.slug, w]));
  
  let updated = 0;
  let failed = 0;
  let skipped = 0;
  
  for (const img of fixableImages) {
    const work = worksBySlug.get(img.slug);
    
    if (!work) {
      log(`Work not found: ${img.slug}`, 'error');
      failed++;
      continue;
    }
    
    const primaryMedia = work.media?.find(m => m.isPrimary) || work.media?.[0];
    
    if (!primaryMedia) {
      log(`No media for work: ${img.slug}`, 'error');
      failed++;
      continue;
    }
    
    // Construct new URL
    const cleanCdnUrl = CONFIG.bunnyCdnUrl.endsWith('/') 
      ? CONFIG.bunnyCdnUrl.slice(0, -1) 
      : CONFIG.bunnyCdnUrl;
    const newUrl = `${cleanCdnUrl}/works/${img.category}/${img.suggestedFilename}`;
    
    // Check if URL is the same
    if (primaryMedia.url === newUrl) {
      log(`URL unchanged: ${img.slug}`, 'info');
      skipped++;
      continue;
    }
    
    console.log(`\n${img.title} (${img.category})`);
    console.log(`  Old: ${primaryMedia.url}`);
    console.log(`  New: ${newUrl}`);
    
    if (isDryRun) {
      log(`  DRY RUN - Would update`, 'info');
      continue;
    }
    
    // Update workMedia
    try {
      await db.update(workMedia)
        .set({ url: newUrl })
        .where(eq(workMedia.id, primaryMedia.id));
      
      // Update media table
      const mediaEntry = await db.query.media.findFirst({
        where: eq(media.url, primaryMedia.url),
      });
      
      if (mediaEntry) {
        await db.update(media)
          .set({ url: newUrl })
          .where(eq(media.id, mediaEntry.id));
      }
      
      log(`  Updated successfully`, 'success');
      updated++;
    } catch (error) {
      log(`  Update failed: ${error}`, 'error');
      failed++;
    }
  }
  
  console.log('\n' + '='.repeat(60));
  console.log('ðŸ“Š UPDATE SUMMARY');
  console.log('='.repeat(60));
  console.log(`Total images: ${fixableImages.length}`);
  console.log(`âœ… Updated: ${updated}`);
  console.log(`âŒ Failed: ${failed}`);
  console.log(`â­ï¸  Skipped: ${skipped}`);
}

main().catch(error => {
  log(`Fatal error: ${error}`, 'error');
  process.exit(1);
});
